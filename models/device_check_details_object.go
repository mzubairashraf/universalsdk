// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"
	"strconv"
	"strings"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// DeviceCheckDetailsObject Contains any/all details we want to pass on to the device/biometric checking service as part of an activity / transaction. A transaction isn't just a payment, but can represent a number of different interaction types. See below for more.
//
// swagger:model DeviceCheckDetailsObject
type DeviceCheckDetailsObject struct {

	// A collection of loosely typed Key-Value-Pairs, which contain arbitrary data to be passed on to the verification services.
	// The API will verify that:
	//
	//   * the list of "Keys" provided are unique to the call (no double-ups)
	//   * that the Value provided matches the Type specified.
	//
	// Should the verification fail, the error message returned will include information for each KVP pair that fails.
	//
	ActivityData []*KeyValuePairObject `json:"activityData"`

	// The type of activity we're checking. Choices are:
	//
	//  - SIGNUP: Used when an entity is signing up to your service
	//  - LOGIN: Used when an already registered entity is logging in to your service
	//  - PAYMENT: Used when you wish to check that all is well for a payment
	//  - CONFIRMATION: User has confirmed an action and you wish to double check they're still legitimate
	//
	//  You can also supply vendor specific activityTypes if you know them. To do this, make the first character an underscore _.
	//  So for example, to use BioCatch's LOGIN_3 type, you can send "_LOGIN_3" as a value. Note, if you do this, there is no error checking on the Frankie side, and thus if you supply an incorrect value, the call will fail.
	//
	// Enum: [SIGNUP LOGIN PAYMENT CONFIRMATION _<Vendor Specific List>]
	ActivityType string `json:"activityType,omitempty"`

	// The unique session based ID that will be checked against the service.
	// Service key must be unique or an error will be returned.
	//
	CheckSessionKey string `json:"checkSessionKey,omitempty"`

	// Describes the type of check service we need to verify with. Choices are:
	//
	//   - DEVICE: Services that will be checking device characteristics
	//   - BIOMETRIC: Services that will be checking biomentric characteristics
	//   - COMBO: If you're using a service that combines both device and biometric information, use this.
	//
	// Enum: [DEVICE BIOMETRIC COMBO]
	CheckType string `json:"checkType,omitempty"`
}

// Validate validates this device check details object
func (m *DeviceCheckDetailsObject) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateActivityData(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateActivityType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCheckType(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *DeviceCheckDetailsObject) validateActivityData(formats strfmt.Registry) error {

	if swag.IsZero(m.ActivityData) { // not required
		return nil
	}

	for i := 0; i < len(m.ActivityData); i++ {
		if swag.IsZero(m.ActivityData[i]) { // not required
			continue
		}

		if m.ActivityData[i] != nil {
			if err := m.ActivityData[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("activityData" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var deviceCheckDetailsObjectTypeActivityTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["SIGNUP","LOGIN","PAYMENT","CONFIRMATION","_\u003cVendor Specific List\u003e"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		deviceCheckDetailsObjectTypeActivityTypePropEnum = append(deviceCheckDetailsObjectTypeActivityTypePropEnum, v)
	}
}

const (

	// DeviceCheckDetailsObjectActivityTypeSIGNUP captures enum value "SIGNUP"
	DeviceCheckDetailsObjectActivityTypeSIGNUP string = "SIGNUP"

	// DeviceCheckDetailsObjectActivityTypeLOGIN captures enum value "LOGIN"
	DeviceCheckDetailsObjectActivityTypeLOGIN string = "LOGIN"

	// DeviceCheckDetailsObjectActivityTypePAYMENT captures enum value "PAYMENT"
	DeviceCheckDetailsObjectActivityTypePAYMENT string = "PAYMENT"

	// DeviceCheckDetailsObjectActivityTypeCONFIRMATION captures enum value "CONFIRMATION"
	DeviceCheckDetailsObjectActivityTypeCONFIRMATION string = "CONFIRMATION"

	// DeviceCheckDetailsObjectActivityTypeVendorSpecificList captures enum value "_<Vendor Specific List>"
	DeviceCheckDetailsObjectActivityTypeVendorSpecificList string = "_<Vendor Specific List>"
)

// prop value enum
func (m *DeviceCheckDetailsObject) validateActivityTypeEnum(path, location string, value string) error {
	if strings.HasPrefix(value, "_") {
		return nil
	}
	if err := validate.Enum(path, location, value, deviceCheckDetailsObjectTypeActivityTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DeviceCheckDetailsObject) validateActivityType(formats strfmt.Registry) error {

	if swag.IsZero(m.ActivityType) { // not required
		return nil
	}

	// value enum
	if err := m.validateActivityTypeEnum("activityType", "body", m.ActivityType); err != nil {
		return err
	}

	return nil
}

var deviceCheckDetailsObjectTypeCheckTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["DEVICE","BIOMETRIC","COMBO"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		deviceCheckDetailsObjectTypeCheckTypePropEnum = append(deviceCheckDetailsObjectTypeCheckTypePropEnum, v)
	}
}

const (

	// DeviceCheckDetailsObjectCheckTypeDEVICE captures enum value "DEVICE"
	DeviceCheckDetailsObjectCheckTypeDEVICE string = "DEVICE"

	// DeviceCheckDetailsObjectCheckTypeBIOMETRIC captures enum value "BIOMETRIC"
	DeviceCheckDetailsObjectCheckTypeBIOMETRIC string = "BIOMETRIC"

	// DeviceCheckDetailsObjectCheckTypeCOMBO captures enum value "COMBO"
	DeviceCheckDetailsObjectCheckTypeCOMBO string = "COMBO"
)

// prop value enum
func (m *DeviceCheckDetailsObject) validateCheckTypeEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, deviceCheckDetailsObjectTypeCheckTypePropEnum); err != nil {
		return err
	}
	return nil
}

func (m *DeviceCheckDetailsObject) validateCheckType(formats strfmt.Registry) error {

	if swag.IsZero(m.CheckType) { // not required
		return nil
	}

	// value enum
	if err := m.validateCheckTypeEnum("checkType", "body", m.CheckType); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *DeviceCheckDetailsObject) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *DeviceCheckDetailsObject) UnmarshalBinary(b []byte) error {
	var res DeviceCheckDetailsObject
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
